package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"

	"github.com/chop-dbhi/origins"
)

const (
	datamodelsDomain = "datamodels"
	pedsnetModelName = "pedsnet.v2"
)

func readHTTP(url string, v interface{}) error {
	resp, err := http.Get(url)

	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return json.NewDecoder(resp.Body).Decode(v)
}

func readFile(name string, v interface{}) error {
	f, err := os.Open(name)

	if err != nil {
		return err
	}

	defer f.Close()

	return json.NewDecoder(os.Stdin).Decode(v)
}

func readStream(v interface{}) error {
	return json.NewDecoder(os.Stdin).Decode(v)
}

type Field struct {
	Conventions string `json:"etl_conventions"`

	table *Table
}

type Table struct {
	Convention string `json:"content"`
	Fields     map[string]*Field

	model *Model
}

type Model struct {
	Convention string `json:"content"`
	Tables     map[string]*Table
}

var usageText = `usage: origins-generate-pedsnet-etl [<file> | <url>]

This command takes the output from the PEDSnet ETL conventions document service
(a JSON document) and converts it into facts. The command optionally takes a
file name or URL to a running service. By default it reads from stdin.

This generator outputs facts that augment entities in the PEDSnet v2 data model
generated by Data Models service (https://github.com/chop-dbhi/data-models-service).
A consumer must merge facts from both domains to get a full view of the entities.
`

func main() {
	// Alter the usage function.
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, usageText)
		flag.PrintDefaults()
	}

	flag.Parse()

	args := flag.Args()

	// Reader value required by the CSV interface.
	var (
		m   Model
		err error
	)

	// File name or URL supplied, otherwise read from stdin.
	if len(args) > 1 {
		if strings.HasPrefix(args[0], "http") {
			err = readHTTP(args[0], &m)
		} else {
			err = readFile(args[0], &m)
		}
	} else {
		err = readStream(&m)
	}

	if err != nil {
		log.Fatal(err)
	}

	var (
		entity *origins.Ident
		f      *origins.Fact
		facts  origins.Facts
	)

	// Initialize the writer.
	w := origins.NewCSVWriter(os.Stdout)

	// Reflect model.
	entity = &origins.Ident{
		Domain: datamodelsDomain,
		Name:   pedsnetModelName,
	}

	// Reflect model.
	facts, err = origins.Reflect(&m)

	if err != nil {
		log.Fatal(err)
	}

	for _, f = range facts {
		f.Entity = entity

		if err = w.Write(f); err != nil {
			log.Fatal(err)
		}
	}

	// Reflect tables.
	for tname, table := range m.Tables {
		facts, err = origins.Reflect(table)

		if err != nil {
			log.Fatal(err)
		}

		entity.Domain = fmt.Sprintf("%s.%s", datamodelsDomain, pedsnetModelName)
		entity.Name = tname

		for _, f := range facts {
			f.Entity = entity

			if err = w.Write(f); err != nil {
				log.Fatal(err)
			}
		}

		// Reflect fields.
		for fname, field := range table.Fields {
			facts, err = origins.Reflect(field)

			if err != nil {
				log.Fatal(err)
			}

			entity.Domain = fmt.Sprintf("%s.%s.%s", datamodelsDomain, pedsnetModelName, tname)
			entity.Name = fname

			for _, f := range facts {
				f.Entity = entity

				if err = w.Write(f); err != nil {
					log.Fatal(err)
				}
			}
		}
	}

	// Flush remaining bits.
	w.Flush()
}
